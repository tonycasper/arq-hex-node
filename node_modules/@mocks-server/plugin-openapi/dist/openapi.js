"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.openApiRoutes = void 0;
const openapi_types_1 = require("openapi-types");
const json_refs_1 = require("json-refs");
const constants_1 = require("./constants");
const methods = Object.values(openapi_types_1.OpenAPIV3.HttpMethods);
function notEmpty(value) {
    return value !== null && value !== undefined;
}
function replaceTemplateInPath(path) {
    // /api/users/{userId} -> api/users/:userId
    return path.replace(/{(\S*?)}/gim, ":$1");
}
function pathToId(path) {
    // /api/users/{userId} -> api-users-userId
    return path.replace(/^\//gim, "").replace(/\//gim, "-").replace(/[{}]/gim, "");
}
function avoidDoubleSlashes(path) {
    // /api//users -> /api/users
    return path.replace(/\/+/gim, "/");
}
function routeUrl(path, basePath) {
    if (basePath) {
        return avoidDoubleSlashes(`${basePath}/${replaceTemplateInPath(path)}`);
    }
    return replaceTemplateInPath(path);
}
function routeId(path, method, mocksServerId) {
    if (mocksServerId) {
        return mocksServerId;
    }
    return `${method}-${pathToId(path)}`;
}
function isJsonMediaType(mediaType) {
    return mediaType.includes("application/json");
}
function isTextMediaType(mediaType) {
    return mediaType.includes("text/");
}
function openApiResponseBaseVariant(variantType, code, options) {
    let id;
    if (options.customId) {
        id = options.customId;
    }
    else {
        id = options.exampleId ? `${code}-${variantType}-${options.exampleId}` : `${code}-${variantType}`;
    }
    return {
        id,
        type: variantType,
    };
}
function replaceCodeWildcards(code) {
    return code.replace(/X/gim, "0");
}
function hasAnySuccessCode(codes) {
    return !!codes.find((code) => {
        return code.startsWith("1") || code.startsWith("2") || code.startsWith("3");
    });
}
function getStatusCode(code, codes) {
    const statusCodes = codes.map(replaceCodeWildcards);
    if (code === "default") {
        return hasAnySuccessCode(statusCodes) ? 400 : 200;
    }
    return Number(replaceCodeWildcards(code));
}
function openApiResponseExampleToVariant(exampleId, code, variantType, mediaType, openApiResponseExample, openApiResponseHeaders) {
    if (!notEmpty(openApiResponseExample) || !notEmpty(openApiResponseExample.value)) {
        return null;
    }
    const baseVariant = openApiResponseBaseVariant(variantType, code, { exampleId, customId: openApiResponseExample[constants_1.MOCKS_SERVER_VARIANT_ID] });
    return Object.assign(Object.assign({}, baseVariant), { options: {
            headers: Object.assign(Object.assign({}, openApiResponseHeaders), { [constants_1.CONTENT_TYPE_HEADER]: mediaType }),
            status: code,
            body: openApiResponseExample.value
        } });
}
function openApiResponseNoContentToVariant(code, openApiResponse) {
    const baseVariant = openApiResponseBaseVariant(constants_1.VariantTypes.STATUS, code, { customId: openApiResponse[constants_1.MOCKS_SERVER_VARIANT_ID] });
    return Object.assign(Object.assign({}, baseVariant), { options: {
            headers: openApiResponse.headers,
            status: code,
        } });
}
function openApiResponseExamplesToVariants(code, variantType, mediaType, openApiResponseMediaType, openApiResponseHeaders) {
    const examples = openApiResponseMediaType.examples;
    const example = openApiResponseMediaType.example;
    if (notEmpty(examples)) {
        return Object.keys(examples).map((exampleId) => {
            return openApiResponseExampleToVariant(exampleId, code, variantType, mediaType, examples[exampleId], openApiResponseHeaders);
        }).filter(notEmpty);
    }
    const res = openApiResponseExampleToVariant("example", code, variantType, mediaType, { value: example }, openApiResponseHeaders);
    return res ? [res] : null;
}
function openApiResponseMediaToVariants(code, mediaType, openApiResponseMediaType, openApiResponseHeaders) {
    if (!notEmpty(openApiResponseMediaType)) {
        return null;
    }
    if (isJsonMediaType(mediaType)) {
        return openApiResponseExamplesToVariants(code, constants_1.VariantTypes.JSON, mediaType, openApiResponseMediaType, openApiResponseHeaders);
    }
    if (isTextMediaType(mediaType)) {
        return openApiResponseExamplesToVariants(code, constants_1.VariantTypes.TEXT, mediaType, openApiResponseMediaType, openApiResponseHeaders);
    }
    return null;
}
function openApiResponseCodeToVariants(code, openApiResponse) {
    if (!notEmpty(openApiResponse)) {
        return [];
    }
    const content = openApiResponse.content;
    if (content) {
        return Object.keys(content).map((mediaType) => {
            return openApiResponseMediaToVariants(code, mediaType, content[mediaType], openApiResponse.headers);
        }).flat().filter(notEmpty);
    }
    return [openApiResponseNoContentToVariant(code, openApiResponse)];
}
function routeVariants(openApiResponses) {
    if (!notEmpty(openApiResponses)) {
        return [];
    }
    const codes = Object.keys(openApiResponses);
    return codes.map((code) => {
        const response = openApiResponses[code];
        return openApiResponseCodeToVariants(getStatusCode(code, codes), response);
    }).flat().filter(notEmpty);
}
function getCustomRouteId(openApiOperation) {
    return openApiOperation[constants_1.MOCKS_SERVER_ROUTE_ID] || openApiOperation.operationId;
}
function openApiPathToRoutes(path, basePath = "", openApiPathObject) {
    if (!notEmpty(openApiPathObject)) {
        return null;
    }
    return methods.map(method => {
        if (notEmpty(openApiPathObject[method])) {
            const openApiOperation = openApiPathObject[method];
            return {
                id: routeId(path, method, getCustomRouteId(openApiOperation)),
                url: routeUrl(path, basePath),
                method,
                variants: routeVariants(openApiOperation.responses),
            };
        }
    }).filter(notEmpty);
}
function openApiDefinitionToRoutes(openApiDefinition) {
    const openApiDocument = openApiDefinition.document;
    const basePath = openApiDefinition.basePath;
    const paths = openApiDocument.paths || {};
    return Object.keys(paths).map((path) => {
        return openApiPathToRoutes(path, basePath, paths[path]);
    }).flat().filter(notEmpty);
}
function documentRefsErrors(refsResults) {
    const refs = refsResults.refs;
    return Object.keys(refs).map((refKey) => {
        // @ts-expect-error expression of type 'string' can't be used to index type 'ResolvedRefDetails', but resolvedRefDetails.refs is in fact an object
        const ref = refs[refKey];
        if (ref.error) {
            return new Error(ref.error);
        }
        return null;
    }).filter(notEmpty);
}
function addOpenApiRefAlert(alerts, error) {
    alerts.set(String(alerts.flat.length), "Error resolving openapi $ref", error);
}
function resolveDocumentRefs(document, refsOptions, { alerts, logger }) {
    return (0, json_refs_1.resolveRefs)(document, refsOptions).then((res) => {
        if (logger) {
            logger.silly(`Document with resolved refs: '${JSON.stringify(res)}'`);
        }
        const refsErrors = documentRefsErrors(res);
        if (refsErrors.length) {
            if (alerts) {
                refsErrors.forEach((error) => {
                    addOpenApiRefAlert(alerts, error);
                });
            }
            else {
                throw new Error(refsErrors.map((error) => error.message).join(". "));
            }
        }
        return res.resolved;
    }).catch((error) => {
        if (alerts) {
            alerts.set(String(alerts.flat.length), "Error loading openapi definition", error);
            return null;
        }
        return Promise.reject(error);
    });
}
function resolveOpenApiDocumentRefs(openApiDefinition, { defaultLocation, alerts, logger } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const document = yield resolveDocumentRefs(openApiDefinition.document, Object.assign({ location: defaultLocation }, openApiDefinition.refs), { alerts, logger });
        if (document) {
            return Object.assign(Object.assign({}, openApiDefinition), { document });
        }
        return null;
    });
}
function openApiRoutes(openApiDefinition, advancedOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolvedOpenApiDefinition = yield resolveOpenApiDocumentRefs(openApiDefinition, advancedOptions);
        if (!resolvedOpenApiDefinition) {
            return [];
        }
        return openApiDefinitionToRoutes(resolvedOpenApiDefinition);
    });
}
exports.openApiRoutes = openApiRoutes;
